\documentclass[a4paper,12pt]{article}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{color}
\definecolor{grey}{rgb}{0.9,0.9,0.9}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{violet}{rgb}{0.5,0,0.5}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings}
\usepackage{listingsutf8}
\lstloadlanguages{caml}
\lstdefinestyle{listing}{
  language=[Objective]Caml,
  captionpos=t,
  inputencoding=utf8/latin1,
  extendedchars=true,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  breakatwhitespace=true,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  basicstyle=\footnotesize\ttfamily,
  backgroundcolor=\color{grey},
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{teal},
  identifierstyle=\color{black},
  stringstyle=\color{red},
  numberstyle=\color{violet},
}
\lstset{style=listing}
\newcommand{\chevron}[1]{<\! \! #1 \! \!>}

\title{TP2 - Analyse syntaxique descendante}
\author{\textsc{Raphaël Baron} - \textsc{Paul Chaignon}}
\date{\today}

\begin{document}

\maketitle

\section{Grammaire}

\subsection{Nouvelle grammaire}

\begin{equation}
\begin{split}
\chevron{Fichier} & \rightarrow \chevron{Expr} EOF\\
\chevron{Expr} & \rightarrow \chevron{Termb} \chevron{SuiteExpr}\\
\chevron{SuiteExpr} & \rightarrow "ou" \chevron{Expr}\;|\;?\\
\chevron{Termb} & \rightarrow \chevron{Facteurb} \chevron{SuiteTermb}\\
\chevron{SuiteTermb} & \rightarrow "et" \chevron{Termb}\;|\;?\\
\chevron{Facteurb} & \rightarrow \chevron{Relation}\;|\;"(" \chevron{Expr} ")"\;|\;"si" \chevron{Expr} "alors" \chevron{Expr}\\ & "sinon" \chevron{Expr} "fsi"\\
\chevron{Relation} & \rightarrow Ident \chevron{Op} Ident\\
\chevron{Op} & \rightarrow "="\;|\;"<>"\;|\;"<"\;|\;">"\;|\;">="\;|\;"<="\\
\end{split}
\end{equation}

\subsection{Preuve de la propriété LL(1)}

Cette grammaire possède trois éléments avec des successeurs non uniques : $\chevron{SuiteExpr}$, $\chevron{SuiteTermb}$ et $\chevron{Facteurb}$.\\

\underline{Pour $\chevron{SuiteExpr}$ :}\\
$premier("ou" \chevron{Termb} \chevron{SuiteExpr}) = \{"ou"\}$ et $premier(\epsilon) = \emptyset$,\\
donc $premier("ou" \chevron{Termb} \chevron{SuiteExpr}) \cap premier(\epsilon) = \emptyset$\\
$null(\chevron{SuiteExpr})$ avec $premier(\chevron{SuiteExpr}) = \{"ou"\}$ et\\
$suivant(\chevron{SuiteExpr}) = \{\chevron{Termb}\}$ toujours différent de \{"ou"\}\\
$premier(\chevron{SuiteExpr}) \cap suivant(\chevron{SuiteExpr}) = \emptyset$\\

\underline{Pour $\chevron{SuiteTermb}$ :}\\
$premier("et" \chevron{Facteurb} \chevron{SuiteTermb}) = \{"et"\} et premier(\epsilon) = \emptyset$,\\
donc $premier("et" \chevron{Facteurb} \chevron{SuiteTermb}) \cap premier(\epsilon) = \emptyset$\\
$null(\chevron{SuiteTermb})$ avec $premier(\chevron{SuiteTermb}) = \{"et"\}$ et\\
$suivant(\chevron{SuiteTermb}) = \{\chevron{Facteurb}\}$ toujours différent de \{"et"\}\\
$premier(\chevron{SuiteTermb}) \cap suivant(\chevron{SuiteTermb}) = \emptyset$\\

\underline{Pour $\chevron{Facteurb}$ :}\\
$premier(\chevron{Relation}) = Ident$ qui commence toujours par une lettre,\\
$premier("(" \chevron{Expr} ")" ) = \{"("\}$ et\\
$premier("si" \chevron{Expr} "alors" \chevron{Expr} "sinon" \chevron{Expr} "fsi") = \{"si"\}$ donc\\
$premier(\chevron{Relation}) \cap premier("(" \chevron{Expr} ")" ) \cap premier("si" \chevron{Expr} "alors" \chevron{Expr}\\
"sinon" \chevron{Expr} "fsi") = \emptyset$\\
$non null(\chevron{Facteurb})$\\


\section{Questions}

\subsection{}
Les commentaires ne sont pas nécessaires pour exécuter le code; c'est pour cela qu'on les ignore dans l'analyse syntaxique. 

\subsection{}
En construisant un arbre, on vérifie directement que les types de chaque unité correspondent. Ainsi, le parenthésage est, entre autres, déjà géré, on n'a donc pas besoin d'implémenter une pile.

\subsection{}
La propriété LL(1) d'une grammaire garantit que celle-ci ne contient pas d'ambiguïté, c'est à dire que pour une unité lexicale et un token lu, il n'y qu'une seule règle de dérivation possible. La grammaire est déterministe. Ainsi, l'implémentation du compilateur est grandement simplifiée.

\subsection{}
L'intérêt d'un arbre abstrait est surtout la lisibilité. En effet, il est plus plaisant de retrouver l'expression de base en lisant simplement l'arbre de gauche à droite, plutôt qu'en essayant de discerner les racines et noeuds à retenir, comme c'est le cas avec un arbre concret.


\section{Code source}

\lstinputlisting[caption=ulex.ml]{ulex.ml}

\lstinputlisting[caption=anasyn.ml]{anasyn.ml}
\vspace{1cm}


\section{Tests}

\lstinputlisting[caption=tests.ml]{tests.ml}
\vspace{1cm}

\end{document}